socket 选项卡规范：

so_keepalive=8: java文档中是这样规范的, tcp socket两端已经两个小时没有exchange data.
tcp会自动发送一个探针probe给对方，要求对方一定回复报文, 有三种情况：
1. 对方成功返回了期望的ack
2. 返回了rst, 表明对方再rebooted or crashed. 关闭这个socket
3. 没有任何响应，已经关闭了socket.
这个参数的设置就是为了检测对方主机是否奔溃。


so_timeout: 超时机制，必须在阻塞操作之前被设置, 比如 accept(), read(), receive()
如果 timeout expires, 还在阻塞的话就会抛出异常

传统IO 和 线程池 模型的弊端非常明显：
虽然利用线程池可以稍稍微的降低线程资源的操作成本, 但是线程的创建和销毁和切换调度 对于 操作系统来说
是非常重量级的 系统函数, 因为线程是 资源调用的基本单位, 为了创建这个计算单位, 要锁住一些资源, 同时
重新进行大量的计算来分配线程所需要的资源, 线程栈和线程的工作内存等, 还需要保存线程的状态, 用于线程
的切换等.
1. 总之对于操作系统来说, 线程操作, 创建和销毁和切换都是重量级的函数。
2. 线程非常耗费内存 一个线程至少分配512K-1M的内存空间, 如果创建了上千个线程, JVM的堆内存都会被吃掉



如果利用NIO 和 事件驱动模型来解放线程, 解决同样的线程处理海量连接的瓶颈.
面向事件的方式编写服务端客户端程序.
reactor模型
目前的需求： 移动端盛行, 往往需要面对百万长连接的任务, 传统的BIO显得无能为力。

基础知识：
所有的系统IO 都分为两个阶段, 等待就绪 和 操作。
NIO的特点： socket的读写注册和接收函数, 在等待就绪节点不阻塞, 在操作阶段阻塞消耗CPU, 但是速度非常快. 这句话怎么理解？？ 有点违背。

